# inspired by the vwf planarDrag.vwf behaviour
---
methods:
  linePlaneIntersection:
events:
  pointerDown:
  pointerMove:
  pointerUp:
scripts:
- |
  this.initialize = function() {
    this.planePoint = undefined;
  };

  this.linePlaneIntersection = function(planePoint, planeNormal, linePoint, lineVec) {
    var Vec3 = goog.vec.Vec3;
    var temp = Vec3.createFloat32();
    var vector = Vec3.createFloat32();
    var intersection, dotNumerator, dotDenominator;

    // calculate the distance between the linePoint and the line-plane intersection point
    Vec3.subtract(planePoint, linePoint, temp);
    dotNumerator = Vec3.dot(temp, planeNormal);
    dotDenominator = Vec3.dot(lineVec, planeNormal);

    // line and plane are not parallel
    if (dotDenominator != 0.0) {
      intersection = Vec3.createFloat32();
      // create a vector from the linePoint to the intersection point
      Vec3.scale(lineVec, dotNumerator / dotDenominator, vector); 
      // get the coordinates of the line-plane intersection point
      Vec3.add(linePoint, vector, intersection);
    }

    return intersection;
  }

  this.pointerDown = function(pointerInfo, pickInfo) {
    var Vec3 = goog.vec.Vec3;
    this.planePoint = Vec3.createFloat32FromArray(pickInfo.globalPosition);
  };

  this.pointerUp = function(pointerInfo, pickInfo) {
  };

  // _dView.state.cameraInUse
  // -> THREE.PerspectiveCamera {id: 3, uuid: "9A1888C3-7109-43E5-970D-76CBD72A0D4F", name: "camera", parent: THREE.Scene, children: Array[0]â€¦}
  // vwf.models[0].model.nodes[id]
  // vwf.application()
  // "index-vwf"
  // vwf.models[0].model.nodes[cameraID].worldTransform
  // vwf.models[3].model.state.nodes[_Editor.GetSelectedVWFID()].threeObject

  this.pointerMove = function(pointerInfo, pickInfo) {
    var Vec3 = goog.vec.Vec3;

    // update the camera location and the view vector
    var cameraTranslation = goog.vec.Vec3.createFloat32FromArray(pickInfo.globalSource);
    // we need a way of getting the pointerVector here without using the globalPosition, because that might not have a value
    var pointerVector = Vec3.createFloat32FromArray(pickInfo.pointerVector);
    var planeNormal = Vec3.createFloat32FromArray([-1.0, 0.0, 0.0]); // restrict movement to just the y (in and out) and the z (up and down)
    var newPlaneIntersection = this.linePlaneIntersection(this.planePoint, planeNormal, cameraTranslation, pointerVector);

    if (newPlaneIntersection !== undefined) {
      var translation = Vec3.createFloat32FromArray(this.translation); // was parent...
      var diff = Vec3.createFloat32();

      goog.vec.Vec3.subtract(newPlaneIntersection, this.planePoint, diff);
      this.translation = Vec3.add(translation, diff, Vec3.createFloat32()); // was parent...
      this.planePoint = Vec3.clone(newPlaneIntersection);
    }
  }; //@ sourceURL=drag.ux
