# Copyright 2014, SRI International
---
extends: http://vwf.example.com/scene.vwf
implements:
- begin.cat
- backendtxrx.cat
methods:
  initializeCamera:
  zoom:
  orbit:
  lookAt:
  clearLookAt:
  resetBackend:
  transformGroupingToNode3:
  vwfChildJsonFromGrouping:
  initInstance:
  instance:
properties:
  zoomedValue:
  scaling:
  camTarget:
  backendResetSent:
children:
  # M4_Environment_01_dae:
  #   extends: http://vwf.example.com/node3.vwf
  #   source: /SAVE/models/environments/range/ShootingRange.dae
  #   type: model/vnd.collada+xml
  #   properties:
  #     scale: [ 1, 1, 1 ]
  #     translation: [ 0, 0, 0 ]
  light1:
    extends: http://vwf.example.com/light.vwf
    properties:
      lightType: "directional"
      translation: [ -0.5, 0, 2 ]
      rotation: [ 0, 1, 0, 36 ]
  light2:
    extends: http://vwf.example.com/light.vwf
    properties:
      lightType: "ambient"
  camera:
    extends: "http://vwf.example.com/camera.vwf"
    properties:
scripts:
- |
  this.initialize = function() {
    this.zoomedValue = 0;
    this.scaled = 0;
    this.backendResetSent = false;
    this.future(0).initializeCamera();
  };

  this.initializeCamera = function() {
    this.camera.translation = [ -1.25, 0, 2.2 ];
    this.camera.rotation = [ 0, 0, 1, -90 ];
  };

  this.zoom = function(value) {
    // console.info('zoom ' + value);

    var EPS = 0.00001;
    var scale = 1 - value / 100; // normalize the value
    var tmp = scale;

    if (this.zoomedValue > 0) {
      if (value < EPS) {
        scale = (1 / this.scaling);
        this.scaling = 0;
        value = 0;
      } else {
        scale = (1 / this.scaling) * tmp;
        this.scaling = tmp;
      }
    } else {
      this.scaling = scale;
    }

    this.zoomedValue = value;
    // console.info('scale: ' + scale + ', scaling: ' + this.scaling);
    // Note: assuming target is the origin for now!
    var x = this.camera.translation[0];
    var y = this.camera.translation[1];
    var z = this.camera.translation[2]; // we keep the z as the target z
    var theta = Math.atan2(x, y); // radians
    var phi = Math.atan2(Math.sqrt(x * x + y * y), 0); // radians
    var radius = Math.sqrt(x * x + y * y) * scale;

    //console.info('radius: ' + radius);
    x = radius * Math.sin(phi) * Math.sin(theta);
    y = radius * Math.sin(phi) * Math.cos(theta);
    //console.info('new translation x ' + x + ', y ' + y + ', z ' + z);
    // this.camera.translation = [ x, y, z ];
    this.camera.translateTo([ x, y, z ], 0.125);
  };

  this.orbit = function(theta) {
    // console.info('orbit ' + theta + ' degrees');

    // Note: assuming target is the origin for now!
    var x = this.camera.translation[0];
    var y = this.camera.translation[1];
    var z = this.camera.translation[2];
    var theta = theta * (Math.PI / 180);

    //console.info('offset x ' + x + ', y ' + y + ', z ' + z);
    var phi = Math.atan2(Math.sqrt(x * x + y * y), z); // radians
    var radius = Math.sqrt(x * x + y * y + z * z); // again the origin is the target

    //console.info('theta: ' + theta + ', phi: ' + phi + ' radians, ' + 'radius: ' + radius);
    x = radius * Math.sin(phi) * Math.sin(theta);
    y = radius * Math.sin(phi) * Math.cos(theta);
    z = radius * Math.cos(phi);
    // console.info('new offset x ' + x + ', y ' + y + ', z ' + z);
    this.camera.translation = [ x, y, z ];
    // console.info('target theta ' + theta * (180 / Math.PI));
    // console.info('cam rot quat z2, z3 ' + this.camera.rotation[ 2 ] + ', ' + this.camera.rotation[ 3 ]);
    this.future(0).lookAt(this.camTarget);
  };

  this.clearLookAt = function() {
    this.camera.lookAt = null;
  };

  this.lookAt = function(what) {
    what = what || this.camTarget;

    var lookAt = (what != null)? this[ what ].id : this.id;

    this.camera.lookAt = lookAt;
    this.future(0).clearLookAt();
    // console.info('cam rot quat z2, z3 ' + this.camera.rotation[ 2 ] + ', ' + this.camera.rotation[ 3 ]);
  };

  this.resetBackend = function() {
    var self = this;

    this.query({ type: 'Reset' },
      function() {
        self.backendResetSent = true;
      }
    );
  };

  this.transformGroupingToNode3 = function(obj, node3) {
    var self = this;

    for (var p in obj) {
        if (p == 'groups') {
            obj.groups.forEach(function(group) {
                var children = node3;

                if (group.node) {
                    node3.children[ group.node ] = { extends: "http://vwf.example.com/node3.vwf", children: { } };
                    children = node3.children[ group.node ];
                }

                self.transformGroupingToNode3(group, children);
            });
        } else if (p == 'parts') {
            obj.parts.forEach(function(part) {
                node3.children[ part ] = { extends: "http://vwf.example.com/node3.vwf" };
            });
        }
    }

    return node3;
  };

  this.vwfChildJsonFromGrouping = function(grouping) {
    var groupingObj = JSON.parse(grouping);
    var  baseNode3 = {
      extends: "http://vwf.example.com/node3.vwf",
      type: "model/vnd.collada+xml",
      implements: [ ],
      properties: { },
      children: { },
      grouping: groupingObj.name
    };
    
    var rootNode3 =  this.transformGroupingToNode3(groupingObj, baseNode3);

    return rootNode3;
  };

  this.initInstance = function(name, kbid) {
    this.children[ name ].M4_Carbine_KbId = kbid;
    this.children[ name ].init();
  };

  this.instance = function(backEndId) {
    console.info(this.id + ' instancing tool tray item with name:' + name  + ' id:' + backEndId);

    var self = this;

    self.obj({ type: 'create', ID: backEndId }, function(data) {
      console.info(self.id + ' obj request received data.kbid: ' + data.kbid + ' asseyURL: ' + data.assetURL);
      console.log(JSON.parse(data.grouping));

      if (data.KbId == 'unknown') {
        console.warn(self.id + ' object instance request returned unknown KbId, nothing to instance');
        return;
      }

      var vwf_node3 = self.vwfChildJsonFromGrouping(data.grouping);

      name = vwf_node3.grouping.replace(' ', '_') + '_dae'; // => M4_Carbine_dae
      vwf_node3.source = data.assetURL;
      vwf_node3.implements = [ "catNode3.cat", "backendtxrx.cat" ]; // => initial state, base behavior, and props, vwf include?
      vwf_node3.properties = {
        translation: [ 0, 0, 2 ],
        rotation: [ 1, 0, 0, 270 ], // asset is laying flat, rotate x => -90 or 270
        scale: [ 1, 1, 1 ]
      };

      console.log(vwf_node3);
      self.children.create(name, vwf_node3); // vwf_M4_node3 is the only non-dynamic piece of the instance, we could get the json dynamically
      self.camTarget = name;
      self.future(0).initInstance(name, data.KbId);
      self.future(0).lookAt(self.camTarget);
    });
  }; //# sourceURL=index.vwf
