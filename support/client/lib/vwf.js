( function( window ) {

    window.console && console.info && console.info( "loading vwf" );

    // vwf.js is the main Virtual World Framework manager. It is constructed as a JavaScript module
    // (http://www.yuiblog.com/blog/2007/06/12/module-pattern) to isolate it from the rest of the
    // page's JavaScript environment. The vwf module self-creates its own instance when loaded and
    // attaches to the global window object as window.vwf. Nothing else should affect the global
    // environment.

    window.vwf = new function() {

        window.console && console.info && console.info( "creating vwf" );

        // == Public variables =====================================================================

        // Each model and view module loaded by the main page registers itself here.

        this.modules = [];

        // vwf.initialize() creates an instance of each model and view module configured on the main
        // page and attaches them here.

        this.models = [];
        this.views = [];

        // this.models and this.views are lists of references to the head of each driver pipeline.
        // Define an "actual" property on each that evaluates to a list of references to the
        // pipeline tails. This is a list of the actual drivers after any intermediate stages and is
        // useful for debugging.

        Object.defineProperty( this.models, "actual", {  // TODO: for this.views too once that's converted to use the RequireJS loader

            get: function() {

                // Map the array to the result.

                var actual = this.map( function( model ) {
                    return last( model );
                } );

                // Map the non-integer properties too.

                for ( var propertyName in this ) {
                    if ( isNaN( Number( propertyName ) ) ) {
                        actual[propertyName] = last( this[propertyName] );
                    }
                }

                // Follow a pipeline to the last stage.

                function last( model ) {
                    while ( model.model ) model = model.model;
                    return model;
                }

                return actual;
            }

        } );

        // This is the simulation clock, which contains the current time in milliseconds. Time is
        // controlled by the conference server and updates here as we receive control messages.

        this.now = 0;

        // Nodes that are receiving ticks.

        this.tickable = {
            // models: [],
            // views: [],
            nodeIDs: [],
        };

        // == Private variables ====================================================================

        this.private = {}; // for debugging

        // Components describe the objects that make up the simulation. They may also serve as
        // prototype objects for further derived components. External components are identified by
        // URIs. Once loaded, we save a mapping here from its URI to the node ID of its prototype so
        // that we can find it if it is reused. Components specified internally as object literals
        // are anonymous and are not indexed here.

        var types = this.private.types = {}; // maps URI => component specification

        // The proto-prototype of all nodes is "node", identified by this URI. This type is
        // intrinsic to the system and nothing is loaded from the URI.

        var nodeTypeURI = "http://vwf.example.com/types/node";

        // Control messages from the conference server are stored here in a priority queue, ordered
        // by execution time.

        var queue = this.private.queue = [];
        queue.time = 0; // current server time
        queue.ready = true;

        // This is the connection to the conference server. In this sample implementation, "socket"
        // is a socket.io client that communicates over a channel provided by the server hosting the
        // client documents.

        var socket = this.private.socket = undefined;

        // Cached version of window.location.search query parameters generated by getQueryString().

        var queryStringParams = this.private.queryStringParams = undefined;

        // Each node is assigned an ID as it is created. This is the most recent ID assigned.

        // Communication between the manager and the models and views uses these IDs to refer to the
        // nodes. The manager doesn't maintain any particular state for the nodes and knows them
        // only as their IDs. The models work in federation to provide the meaning to each node.

        // var lastID = 0;

        // Callback functions defined in this scope use this local "vwf" to locate the manager.

        var vwf = this;

        // == Public functions =====================================================================

        // -- initialize ---------------------------------------------------------------------------

        // The main page only needs to call vwf.initialize() to launch the application. Use
        // require.ready() or jQuery(document).ready() to call initialize() once the page has
        // loaded. initialize() accepts three parameters.
        
        // A component specification identifies the world to be loaded. If a URI is provided, the
        // specification is loaded from there [1]. Alternately, a JavaScript object literal
        // containing the specfication may be provided [2]. Since a component can extend and
        // specialize a prototype, using a simple object literal allows existing component to be
        // configured for special uses [3].
        // 
        //     [1] vwf.initialize( "http://vwf.example.com/worlds/sample12345", ... )
        //
        //     [2] vwf.initialize( { source: "model.dae", type: "model/vnd.collada+xml",
        //             properties: { "p1": ... }, ... }, ... )
        //
        //     [3] vwf.initialize( { extends: "http://vwf.example.com/worlds/sample12345",
        //             source: "alternate-model.dae", type: "model/vnd.collada+xml" }, ... )
        // 
        // modelArguments and viewArguments identify the model and view modules that should be
        // attached to the simulation and provides their configuration parameters. Each argument set
        // is specified as an object (hash) in which each key is the name of a model or view to
        // construct, and the value is the set of arguments to pass to the constructor. The
        // arguments may be specified as an array of values [4], or as a single value if there is
        // only one [5].
        // 
        //     [4] vwf.initialize( ..., { scenejs: "#scene" }, { ... } )
        //     [5] vwf.initialize( ..., { ... }, { html: [ "#world", "second param" ] } )

        this.initialize = function( /* [ componentURI|componentObject ] [ modelArguments ]
            [ viewArguments ] */ ) {

            var args = Array.prototype.slice.call( arguments );

            // Get the world specification if one is provided in the query string. Parse it into a
            // world specification object if it's valid JSON, otherwise keep the query string and
            // assume it's a URI.

            var application = getQueryString( "application" );

            // Parse the function parameters. If the first parameter is a string or contains
            // component properties, then treat it as the world specification. Otherwise, fall back
            // to the "application" parameter in the query string.

            if ( typeof args[0] == "string" || args[0] instanceof String || objectIsComponent( args[0] ) ) {
                application = args.shift();
            }

            // Shift off the parameter containing the model argument lists.

            var modelArgumentLists = args.shift() || {};

            if ( typeof modelArgumentLists != "object" && ! modelArgumentLists instanceof Object )
                modelArgumentLists = {};

            // Shift off the parameter containing the view argument lists.

            var viewArgumentLists = args.shift() || {};

            if ( typeof viewArgumentLists != "object" && ! viewArgumentLists instanceof Object )
                viewArgumentLists = {};

            // Create and attach each configured model.

            jQuery.each( modelArgumentLists, function( modelName, modelArguments ) {

                var model = require( modelName ).create(
                    vwf,                                        // model's kernel access
                    [ require( "vwf/model/stage/log" ) ],       // stages between the kernel and model
                    {}                                          // state shared with a paired view
                    // TODO: configuration parameters (modelArguments)
                );

                if ( model ) {
                    vwf.models.push( model );
                    vwf.models[modelName] = model; // also index by id  // TODO: this won't work if multiple model instances are allowed

if ( modelName == "vwf/model/javascript" ) {  // TODO: need a formal way to follow prototype chain from vwf.js; this is peeking inside of vwf-model-javascript
    vwf.models.javascript = model;
    while ( vwf.models.javascript.model ) vwf.models.javascript = vwf.models.javascript.model;
}

if ( modelName == "vwf/model/object" ) {  // TODO: this is peeking inside of vwf-model-object
    vwf.models.object = model;
    while ( vwf.models.object.model ) vwf.models.object = vwf.models.object.model;
}
                }

            } );

            // Create and attach each configured view.

            jQuery.each( viewArgumentLists, function( viewName, viewArguments ) {

                var view = vwf.modules[viewName];

                if ( view ) {
                    var instance = new view();
                    instance.state = vwf.models.actual["vwf/model/"+viewName] && vwf.models.actual["vwf/model/"+viewName].state || {}; // state shared with a paired model
                    view.apply( instance, [ vwf ].concat( viewArguments || [] ) );
                    vwf.views.push( instance );
                    vwf.views[viewName] = instance; // also index by id  // TODO: this won't work if multiple model instances are allowed
                }

            } );

            // Load the world.

            vwf.ready( application );

        };

        // -- ready --------------------------------------------------------------------------------

        this.ready = function( component_uri_or_json_or_object ) {

            // Connect to the conference server. This implementation uses the socket.io library,
            // which communicates using a channel back to the server that provided the client
            // documents.

            try {

                socket = new io.Socket( undefined, {

                    // The socket is relative to the application path.

                    resource: window.location.pathname.slice( 1,
                        window.location.pathname.lastIndexOf("/") ),

                    // The ruby socket.io server only supports WebSockets. Don't try the others.

                    transports: [
                        'websocket',
                        // 'flashsocket',
                        // 'htmlfile',
                        // 'xhr-multipart',
                        // 'xhr-polling',
                        // 'jsonp-polling',
                    ],

                    // Increase the timeout due to starvation while loading the scene. The server
                    // timeout must also be increased.
                    // TODO: reinstate if needed, but this needs to be handled by communicating during the load.

                    // transportOptions: {
                    //     "websocket": { timeout: 90000 },
                        // "flashsocket": { timeout: 90000 },
                        // "htmlfile": { timeout: 90000 },
                        // "xhr-multipart": { timeout: 90000 },
                        // "xhr-polling": { timeout: 90000 },
                        // "jsonp-polling": { timeout: 90000 },
                    // }

    			} );

            } catch ( e ) {

                // If a connection to the conference server is not available, then run in single-
                // user mode. Messages intended for the conference server will loop directly back to
                // us in this case. Start a timer to monitor the incoming queue and dispatch the
                // messages as though they were received from the server.

                this.dispatch( 0 );

                setInterval( function() {
                    vwf.dispatch( vwf.now + 10 ); // TODO: there will be a slight skew here since the callback intervals won't be exactly 10 ms; increment using the actual delta time; also, support play/pause/stop and different playback rates as with connected mode.
                }, 10 );

            }

            if ( socket ) {

                socket.on( "connect", function() { vwf.logger.info( "vwf.socket connected" ) } );

                // Configure a handler to receive messages from the server.
                
                // Note that this example code doesn't implement a robust parser capable of handling
                // arbitrary text and that the messages should be placed in a dedicated priority
                // queue for best performance rather than resorting the queue as each message
                // arrives. Additionally, overlapping messages may cause actions to be performed out
                // of order in some cases if messages are not processed on a single thread.

                socket.on( "message", function( message ) {

                    // this.logger.info( "vwf.socket message " + message );

                    try {

                        // Unpack the arguments.

                        fields = JSON.parse( message );
                        fields.time = Number( fields.time );
                        // TODO: other message validation (check node id, others?)

                        // Add the message to the queue and keep it ordered by time.

                        queue.push( fields );
                        queue.time = fields.time || queue.time; // current server time

                        queue.sort( function( a, b ) {
                            return a.time - b.time
                        } );  // TODO: sort must be stable so that messages with the same time are evaluated in the order that they arrive; also ensure that new messages added at the same time as other messages in the queue are inserted after them

                        // Each message from the server allows us to move time forward. Parse the
                        // timestamp from the message and call dispatch() to execute all queued
                        // actions through that time, including the message just received.
                    
                        // The simulation may perform immediate actions at the current time or it
                        // may post actions to the queue to be performed in the future. But we only
                        // move time forward for items arriving in the queue from the conference
                        // server.

                        vwf.dispatch( fields.time );

                    } catch( e ) {

                        // Ignore invalid messages.

                    }

                } );

                socket.on( "disconnect", function() { vwf.logger.info( "vwf.socket disconnected" ) } );

                // Start communication with the conference server. 

                socket.connect();  // TODO: errors can occur here too, particularly if a local client contains the socket.io files but there is no server; do the loopback here instead of earlier in response to new io.Socket.

            } else if ( component_uri_or_json_or_object ) {

                // Load the world. The world is a rooted in a single node constructed here as an
                // instance of the component passed to initialize(). That component, its
                // prototype(s), and its children, and their prototypes and children, flesh out the
                // entire world.

                // TODO: add note that this is only for a self-determined world; with socket, wait for reflection server to tell us.
                // TODO: maybe depends on component_uri_or_json_or_object too; when to override and not connect to reflection server?

                this.createNode( component_uri_or_json_or_object, function( rootID, rootTypeID ) {
                    vwf.addChild( 0, rootID, undefined );
                } );

            } else {  // TODO: also do this if component_uri_or_json_or_object was invalid and createNode() failed

                // TODO: show a selection dialog

            }

        };

        // -- send ---------------------------------------------------------------------------------

        // Send a message to the conference server. The message will be reflected back to all
        // participants in the conference.

        this.send = function( /* nodeID, actionName, parameters ... */ ) {

            var args = Array.prototype.slice.call( arguments );

            // Attach the current simulation time and pack the message as an array of the arguments.

            var fields = {
                time: this.now,
                node: args.shift(),
                action: args.shift(),
                parameters: args
            };

            if ( socket ) {

                // Send the message if the connection is available.

                var message = JSON.stringify( fields );
                socket.send( message );

            } else {
                
                // Otherwise, for single-user mode, loop it immediately back to the incoming queue.

                queue.push( fields );
                queue.time = fields.time || queue.time;

                queue.sort( function( a, b ) {
                    return a.time - b.time
                } );  // TODO: sort must be stable so that messages with the same time are evaluated in the order that they arrive; also ensure that new messages added at the same time as other messages in the queue are inserted after them

            }

        };

        // -- receive ------------------------------------------------------------------------------

        // Handle receipt of a message. Unpack the arguments and call the appropriate handler.

        this.receive = function( fields, callback /* ( ready ) */ ) {

            // Advance the time and locate the node ID and action name.

            this.now = fields.time;

            var nodeID = fields.node;
            var actionName = fields.action;

// TODO: delegate parsing and validation to each action.

            // Look up the action handler and invoke it with the remaining parameters.

            // Note that the message should be validated before looking up and invoking an arbitrary
            // handler.

            var args = nodeID || nodeID === 0 ? [ nodeID ].concat( fields.parameters ) : fields.parameters;

            // Insert the ready callback for potentially-asynchronous actions.

            switch ( actionName ) {

                case "createNode":

                    callback( false ); // suspend the queue

                    args[1] = function( nodeID, prototypeID ) {
                        vwf.addChild( 0, nodeID, undefined );
                        callback( true ); // resume the queue when the action completes
                    };

                    break;

            }

            // Invoke the action.

            var result = this[actionName] && this[actionName].apply( this, args );

if ( socket && actionName == "getNode" ) {  // TODO: merge with send()

    var fieldsout = {
        time: fields.time,
        node: fields.node,
        action: fields.action,
        parameters: fields.parameters,
        result: result
    };

    var message = JSON.stringify( fieldsout );
    socket.send( message );

}

            
        };

        // -- dispatch -----------------------------------------------------------------------------

        // Dispatch incoming messages waiting in the queue. "currentTime" specifies the current
        // simulation time that we should advance to and was taken from the time stamp of the last
        // message received from the conference server.

        this.dispatch = function( currentTime ) {

            // Handle messages until we empty the queue or reach the new current time. For each,
            // remove the message and perform the action. The simulation time is advanced to the
            // message time as each one is processed.

            // Actions may use receive's ready function to suspend the queue for asynchronous
            // operations, and to resume it when the operation is complete.

            while ( queue.ready && queue.length > 0 && queue[0].time <= currentTime ) {

                var fields = queue.shift();

                this.receive( fields, function( ready ) {
                    if ( Boolean( ready ) != Boolean( queue.ready ) ) {
                        vwf.logger.info( "vwf.dispatch:", ready ? "resuming" : "pausing", "queue at time", currentTime, "for", fields.action );
                        queue.ready = ready;
                        queue.ready && vwf.dispatch( queue.time );
                    }
                } );

            }

            // Set the simulation time to the new current time.

            if ( queue.ready ) {
                this.now = currentTime;
            }

            this.tick();
            
        };

        // -- dispatch -----------------------------------------------------------------------------

        // Dispatch incoming messages waiting in the queue. "currentTime" specifies the current
        // simulation time that we should advance to and was taken from the time stamp of the last
        // message received from the conference server.

        this.tick = function() {

            // Call ticking() on each model.

            vwf.models.forEach( function( model ) {
                model.ticking && model.ticking( vwf.now ); // TODO: maintain a list of tickable models and only call those
            } );

            // Call ticked() on each view.

            vwf.views.forEach( function( view ) {
                view.ticked && view.ticked( vwf.now ); // TODO: maintain a list of tickable views and only call those
            } );

            // Call tick() on each tickable node.

            vwf.tickable.nodeIDs.forEach( function( nodeID ) {
                vwf.callMethod( nodeID, "tick", vwf.now );
            } );

        };

        // -- createNode ---------------------------------------------------------------------------

        // Create a node from a component specification. Construction may require loading data from
        // multiple remote documents. This function returns before construction is complete. A
        // callback is invoked once the node has fully loaded.
        // 
        // A simple node consists of a set of properties, methods and events, but a node may
        // specialize a prototype component and may also contain multiple child nodes, any of which
        // may specialize a prototype component and contain child nodes, etc. So components cover a
        // vast range of complexity. The world definition for the overall simulation is a single
        // component instance.
        // 
        // A node is a component instance--a single, anonymous specialization of its component.
        // Nodes specialize components in the same way that any component may specialize a prototype
        // component. The prototype component is made available as a base, then new or modified
        // properties, methods, events, child nodes and scripts are attached to modify the base
        // implemenation.
        // 
        // To create a node, we first make the prototoype available by loading it (if it has not
        // already been loaded). This is a recursive call to createNode() with the prototype
        // specification. Then we add new, and modify existing, properties, methods, and events
        // according to the component specification. Then we load an add any children, again
        // recursively calling createNode() for each. Finally, we attach any new scripts and invoke
        // an initialization function.

        this.createNode = function( component_uri_or_json_or_object, callback, childName /* TODO: hack */ ) {

            this.logger.group( "vwf.createNode " + (
                typeof component_uri_or_json_or_object == "string" || component_uri_or_json_or_object instanceof String ?
                    component_uri_or_json_or_object : JSON.stringify( loggableComponent( component_uri_or_json_or_object ) )
            ) );

            // Any component specification may be provided as either a URI identifying a network
            // resource containing the specification or as an object literal that provides the data
            // directly.

            var component = normalizedComponent( component_uri_or_json_or_object );

            // Allocate an ID for the node. We just use an incrementing counter.  // TODO: must be unique and consistent regardless of load order; this is a gross hack.

            var nodeID = ( component["extends"] || nodeTypeURI ) + "." + childName;
nodeID = nodeID.replace( /[^0-9A-Za-z_]+/g, "-" ); // stick to HTML id-safe characters
// nodeID = nodeID + "-" + Math.round( Math.random() * 1000000 );  // TODO: for single-user mode testing only; don't require the tests to provide the childName hack

            this.logger.info( "vwf.createNode: creating node of type " + ( component["extends"] || nodeTypeURI ) + " with id " + nodeID );

            // Call getType() to locate or load the prototype node, then pass the prototype and the
            // component specification to construct().

if ( ! callback ) { // TODO: this is a hack to get the multiuser application createNode to addChild to the root
    callback = function( nodeID, prototypeID ) {
        vwf.addChild( 0, nodeID, undefined );
    };
}

// nodeID = nodeID + "-" + Date.now();  // TODO: hack on a hack to allow (single-user mode) client tests to work
    
            this.getType( component["extends"] || nodeTypeURI, function( prototypeID ) { // TODO: could be a JSON-encoded type literal as with world param?
                construct.call( this, component, nodeID, prototypeID, callback /* ( nodeID, prototypeID ) */ );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.createNode complete " + component_uri_or_json_or_object ); /* must log something for group level to reset in WebKit */
        };

        // -- getType ------------------------------------------------------------------------------

        // Find or load a node that will serve as the prototype for a component specification. If
        // the component is identified using a URI, save a mapping from the URI to the prototype ID
        // in the "types" database for reuse. If the component is not identified by a URI, don't
        // save a reference in the database (since no other component can refer to it), and just
        // create it as an anonymous type.

        this.getType = function( uri, callback ) {

            var nodeID = uri; // TODO: hash uri => nodeID to shorten for faster lookups? // TODO: canonicalize uri
nodeID = nodeID.replace( /[^0-9A-Za-z_]+/g, "-" ); // stick to HTML id-safe characters

if ( uri[0] == "@" ) {  // TODO: this is allowing an already-loaded nodeID to be used in place of an extends uri; this is primarily to support the tests, but should be eventually be fully supported.
    nodeID = JSON.parse( uri.slice( 1 ) );
    types[nodeID] = "dummy";
}

            // If the type is being loaded, add the callback to the list to be invoked when the load
            // completes.

            if ( types[nodeID] instanceof Array ) {

                types[nodeID].push( callback );

            // If the URI is in the database, invoke the callback with the ID of the previously-
            // loaded prototype node.
            
            } else if ( types[nodeID] ) {

                callback && callback.call( this, nodeID );

            // If the type has not been loaded, call createNode() to make the node that we will use
            // as the prototype. When it loads, save the ID in the types database and invoke the
            // callback with the new prototype node's ID.

            // nodeTypeURI is a special URI identifying the base "node" component that is the
            // ultimate prototype of all other components. Its specification is known
            // intrinsicly and does not exist as a network resource. If the component URI
            // identifies "node", call construct() directly and pass a null prototype and an
            // empty specification.

            } else if ( uri == nodeTypeURI ) {

                types[nodeID] = [ callback ]; // array of callbacks while loading

                var component = {};
                var prototypeID = undefined;

                this.logger.info( "vwf.getType: creating type " + uri );

                construct.call( this, component, nodeID, prototypeID, function( nodeID, prototypeID ) {

                    var callbacks = types[nodeID];
                    types[nodeID] = component; // component specification once loaded

                    callbacks.forEach( function( callback ) {
                        callback && callback.call( vwf, nodeID );
                    } );

                } );

            // For any other URI, load the document. Once it loads, call getType() to locate or
            // load the prototype node, then pass the prototype and the component specification
            // to construct().

            } else {

                this.logger.info( "vwf.getType: creating type " + uri );

                types[nodeID] = [ callback ]; // array of callbacks while loading

                jQuery.ajax( {

                    url: remappedURI( uri ),
                    dataType: "jsonp",

                    success: function( component ) {

                        this.getType( component["extends"] || nodeTypeURI, function( prototypeID ) { // TODO: if object literal?

                            construct.call( this, component, nodeID, prototypeID, function( nodeID, prototypeID ) {

                                var callbacks = types[nodeID];
                                types[nodeID] = component; // component specification once loaded

                                callbacks.forEach( function( callback ) {
                                    callback && callback.call( vwf, nodeID );
                                } );

                            } );

                        } )

                    },

                    context: this

                } );

            }

        };




        // -- setNode ------------------------------------------------------------------------------

        this.setNode = function( nodeID, component ) {

Object.keys( component ).forEach( function( nodeID ) {
    vwf.setProperties( nodeID, component[nodeID] );
} );

return;

            var prototypeID = this.prototype( nodeID );
            var childrenIDs = this.children( nodeID );

            if ( prototypeID && component.extends ) {
                this.setNode( prototypeID, component.extends );
            }

            // implements: [ ? ]  // TODO

            component.properties && this.setProperties( nodeID, component.properties );
            // component.methods  // TODO
            // component.events  // TODO

            component.children && childrenIDs.forEach( function( childID, childIndex ) {
                component.children[childIndex] && vwf.setNode( childID, component.children[childIndex] );
            } );

            return component;
        };

        // -- getNode ------------------------------------------------------------------------------

        this.getNode = function( nodeID ) {

            var component = {};

Object.keys( vwf.models.object.objects ).forEach( function( nodeID ) {
    component[nodeID] = vwf.getProperties( nodeID );
    Object.keys( component[nodeID] ).length || delete component[nodeID];
} );

return component;

            var prototypeID = this.prototype( nodeID );
            var childrenIDs = this.children( nodeID );

            if ( prototypeID !== undefined ) {
                component.extends = this.getNode( prototypeID );
                Object.keys( component.extends ).length || delete component.extends;
            }

            // implements: [ ? ]  // TODO

            component.properties = this.getProperties( nodeID );

            for ( var propertyName in component.properties ) {
                component.properties[propertyName] === undefined && delete component.properties[propertyName];
            }

            Object.keys( component.properties ).length || delete component.properties;

            component.methods = {};  // TODO

            for ( var methodName in component.methods ) {
                component.methods[methodName] === undefined && delete component.methods[methodName];
            }

            Object.keys( component.methods ).length || delete component.methods;

            component.events = {};  // TODO

            for ( var eventName in component.events ) {
                component.events[eventName] === undefined && delete component.events[eventName];
            }

            Object.keys( component.events ).length || delete component.events;
            
            if ( childrenIDs.length ) {
                component.children = childrenIDs.map( function( childID ) {
                    return vwf.getNode( childID );
                } );
            }

            return component;
        };


        // -- prototype ----------------------------------------------------------------------------

        this.prototype = function( nodeID ) {

            // Call prototyping() on each model. The first model to return a non-undefined value
            // dictates the return value.

            var prototypeID = undefined;

            vwf.models.some( function( model ) {
                prototypeID = model.prototyping && model.prototyping( nodeID );
                return prototypeID !== undefined;
            } );

            return prototypeID;
        }

        // -- prototypes ---------------------------------------------------------------------------

        this.prototypes = function( nodeID ) {

            var prototypeIDs = [];
            var prototypeID = undefined;
            
            while ( nodeID !== undefined ) {
                if ( ( prototypeIDs.prototype( nodeID ) ) !== undefined ) { // assignment is intentional
                    prototypeIDs.push( prototypeID );
                }
                nodeID = prototypeID;
            }
            
            return prototypeIDs;
        }


        // -- addChild -----------------------------------------------------------------------------

        this.addChild = function( nodeID, childID, childName ) {

            this.logger.group( "vwf.addChild " + nodeID + " " + childID + " " + childName );

            // Call addingChild() on each model. The child is considered added after each model has
            // run.

            vwf.models.forEach( function( model ) {
                model.addingChild && model.addingChild( nodeID, childID, childName );
            } );

            // Call addedChild() on each view. The view is being notified that a child has been
            // added.

            vwf.views.forEach( function( view ) {
                view.addedChild && view.addedChild( nodeID, childID, childName );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.addChild complete " + nodeID + " " + childID + " " + childName ); /* must log something for group level to reset in WebKit */
        };

        // -- removeChild --------------------------------------------------------------------------

        this.removeChild = function( nodeID, childID ) {

            this.logger.group( "vwf.removeChild " + nodeID + " " + childID );

            // Call removingChild() on each model. The child is considered removed after each model
            // has run.

            vwf.models.forEach( function( model ) {
                model.removingChild && model.removingChild( nodeID, childID );
            } );

            // Call removedChild() on each view. The view is being notified that a child has been
            // removed.

            vwf.views.forEach( function( view ) {
                view.removedChild && view.removedChild( nodeID, childID );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.removeChild complete " + nodeID + " " + childID ); /* must log something for group level to reset in WebKit */
        };

        // -- parent -------------------------------------------------------------------------------

        this.parent = function( nodeID ) {

            // Call parenting() on each model. The first model to return a non-undefined value
            // dictates the return value.

            var parent = undefined;

            vwf.models.forEach( function( model ) {
                var modelParent = model.parenting && model.parenting( nodeID );
                parent = modelParent !== undefined ? modelParent  : parent;
            } );

            return parent;
        };

        // -- children -----------------------------------------------------------------------------

        this.children = function( nodeID ) {

            this.logger.group( "vwf.children " + nodeID );

            // Call childrening() on each model. The return value is the union of the non-undefined
            // results.

            var children = [];

            vwf.models.forEach( function( model ) {
                var modelChildren = model.childrening && model.childrening( nodeID ) || [];
                Array.prototype.push.apply( children, modelChildren );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.children complete " + nodeID ); /* must log something for group level to reset in WebKit */

            return children; // TODO: remove duplicates, hopefully without re-ordering.
        };

        // -- name ---------------------------------------------------------------------------------

        this.name = function( nodeID ) {

            // Call naming() on each model. The first model to return a non-undefined value dictates
            // the return value.

            var name = undefined;

            vwf.models.forEach( function( model ) {
                var modelName = model.naming && model.naming( nodeID );
                name = modelName !== undefined ? modelName : name;
            } );

            return name;
        };

        // -- setProperties ------------------------------------------------------------------------

        // Set all of the properties for a node.

        this.setProperties = function( nodeID, properties ) {

            this.logger.group( "vwf.setProperties " + nodeID + " " + properties );

            // Call settingProperties() on each model.

            properties = vwf.models.reduceRight( function( intermediate_properties, model ) {

                var model_properties = model.settingProperties &&
                    model.settingProperties( nodeID, properties );  // TODO: if no settingProperties, call settingProperty on each (resolve include/exclude proto)

                for ( var propertyName in model_properties || {} ) {
                    intermediate_properties[propertyName] = model_properties[propertyName];
                }

                return intermediate_properties;

            }, {} );

            // Call satProperties() on each view.

            vwf.views.forEach( function( view ) {

                if ( view.satProperties ) {
                    view.satProperties( nodeID, properties );
                } else if ( view.satProperty ) {
                    for ( var propertyName in properties ) {
                        view.satProperty( nodeID, propertyName, properties[propertyName] );

                    }
                }

            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.settingProperties complete " + nodeID ); /* must log something for group level to reset in WebKit */

            return properties;
        };

        // -- getProperties ------------------------------------------------------------------------

        // Get all of the properties for a node.

        this.getProperties = function( nodeID ) {

            this.logger.group( "vwf.getProperties " + nodeID );

            // Call gettingProperties() on each model.

            var properties = vwf.models.reduceRight( function( intermediate_properties, model ) {

                var model_properties = model.gettingProperties &&
                    model.gettingProperties( nodeID, intermediate_properties );

                for ( var propertyName in model_properties || {} ) {
if ( nodeID != "http-vwf-example-com-types-node3-LCD" && nodeID != "http-vwf-example-com-types-material-ic40RedMaterial1" )  // blacklist certain nodes and properties that aren't updating correctly  // TODO: this is due to the delayed load problems and property inconsistency
                    intermediate_properties[propertyName] = model_properties[propertyName];
                }

                return intermediate_properties;

            }, {} );

            // Call gotProperties() on each view.

            vwf.views.forEach( function( view ) {
                view.gotProperties && view.gotProperties( nodeID, properties );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.gettingProperties complete " + nodeID ); /* must log something for group level to reset in WebKit */

            return properties;
        };

        // -- createProperty -----------------------------------------------------------------------

        // Create a property on a node and assign an initial value.

        this.createProperty = function( nodeID, propertyName, propertyValue, propertyGet, propertySet ) {

            this.logger.group( "vwf.createProperty " + nodeID + " " + propertyName + " " + propertyValue );  // TODO: add truncated propertyGet, propertySet to log

            // Call creatingProperty() on each model. The property is considered created after each
            // model has run.

            vwf.models.forEach( function( model ) {
                model.creatingProperty && model.creatingProperty( nodeID, propertyName, propertyValue, propertyGet, propertySet );
            } );

            // Call createdProperty() on each view. The view is being notified that a property has
            // been created.

            vwf.views.forEach( function( view ) {
                view.createdProperty && view.createdProperty( nodeID, propertyName, propertyValue, propertyGet, propertySet );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.createProperty complete " + nodeID + " " + propertyName + " " + propertyValue ); /* must log something for group level to reset in WebKit */  // TODO: add truncated propertyGet, propertySet to log
        };

        // -- setProperty --------------------------------------------------------------------------

        // Set a property value on a node.

        this.setProperty = function( nodeID, propertyName, propertyValue ) {

            this.logger.group( "vwf.setProperty " + nodeID + " " + propertyName + " " + propertyValue );

            // Record calls into this function by nodeID and propertyName so that models may call
            // back here (directly or indirectly) to delegate responses further down the chain
            // without causing infinite recursion.

            var entrants = arguments.callee.entrants;

            var entry = entrants[nodeID+'-'+propertyName] || {}; // the most recent call, if any  // TODO: need unique nodeID+propertyName hash
            var reentry = entrants[nodeID+'-'+propertyName] = {}; // this call

            // Call settingProperty() on each model. The first model to return a non-undefined value
            // has performed the set and dictates the return value. The property is considered set
            // after each model has run.

            vwf.models.some( function( model, index ) {

                // Skip models up through the one making the most recent call here (if any).

                if ( index > entry.index || entry.index === undefined ) {

                    // Record the active model number.
 
                    reentry.index = index;

                    // Make the call.

                    var value = model.settingProperty &&
                        model.settingProperty( nodeID, propertyName, propertyValue );

                    // Look for a return value potentially stored by a reentrant call here if the
                    // model didn't return one explicitly (such as with a JavaScript accessor
                    // method).

                    if ( value === undefined )
                        value = reentry.value;

                    delete reentry.value;

                    // If we have a return value, save it and exit from Array.some().

                    if ( value !== undefined ) {
                        propertyValue = value;
                        return true;
                    }

                }

            } );

            if ( entry.index !== undefined ) {

                // For a reentrant call, restore the previous state and record the current result.

                entrants[nodeID+'-'+propertyName] = entry;
                entry.value = propertyValue;

            } else {

                // Delete the call record if this is the first, non-reentrant call here (the normal
                // case).

                delete entrants[nodeID+'-'+propertyName];

                // Call satProperty() on each view. The view is being notified that a property has
                // been set.  TODO: only want to call when actually set and with final value

                vwf.views.forEach( function( view ) {
                    view.satProperty && view.satProperty( nodeID, propertyName, propertyValue );
                } );

            }

            this.logger.groupEnd(); this.logger.debug( "vwf.setProperty complete " + nodeID + " " + propertyName + " " + propertyValue ); /* must log something for group level to reset in WebKit */

            return propertyValue;
        };

        this.setProperty.entrants = {}; // maps ( nodeID + '-' + propertyName ) => { index: i, value: v }

        // -- getProperty --------------------------------------------------------------------------

        // Get a property value for a node.

        this.getProperty = function( nodeID, propertyName ) {

            this.logger.group( "vwf.getProperty " + nodeID + " " + propertyName );

            // Call gettingProperty() on each model. The first model to return a non-undefined value
            // dictates the return value.

            var propertyValue = undefined;

            // Record calls into this function by nodeID and propertyName so that models may call
            // back here (directly or indirectly) to delegate responses further down the chain
            // without causing infinite recursion.

            var entrants = arguments.callee.entrants;

            var entry = entrants[nodeID+'-'+propertyName] || {}; // the most recent call, if any  // TODO: need unique nodeID+propertyName hash
            var reentry = entrants[nodeID+'-'+propertyName] = {}; // this call

            // Call gettingProperty() on each model. The first model to return a non-undefined value
            // dictates the return value.

            vwf.models.some( function( model, index ) {

                // Skip models up through the one making the most recent call here (if any).

                if ( index > entry.index || entry.index === undefined ) {

                    // Record the active model number.
 
                    reentry.index = index;

                    // Make the call.

                    var value = model.gettingProperty &&
                        model.gettingProperty( nodeID, propertyName, propertyValue );

                    // Look for a return value potentially stored by a reentrant call here if the
                    // model didn't return one explicitly (such as with a JavaScript accessor
                    // method).

                    if ( value === undefined )
                        value = reentry.value;

                    delete reentry.value;

                    // If we have a return value, save it and exit from Array.some().

                    if ( value !== undefined ) {
                        propertyValue = value;
                        return true;
                    }

                }

            } );

            if ( entry.index !== undefined ) {

                // For a reentrant call, restore the previous state and record the current result.

                entrants[nodeID+'-'+propertyName] = entry;
                entry.value = propertyValue;

            } else {

                // Delete the call record if this is the first, non-reentrant call here (the normal
                // case).

                delete entrants[nodeID+'-'+propertyName];

                // Delegate to the prototype if we didn't get a result from the current node.

                if ( propertyValue === undefined ) {
                    var prototypeID = Object.getPrototypeOf( vwf.models.javascript.nodes[nodeID] ).id;  // TODO: need a formal way to follow prototype chain from vwf.js; this is peeking inside of vwf-model-javascript
                    if ( prototypeID != nodeTypeURI.replace( /[^0-9A-Za-z_]+/g, "-" ) ) {
                        propertyValue = vwf.getProperty( prototypeID, propertyName );
                    }
                }

                // Call gotProperty() on each view.

                vwf.views.forEach( function( view ) {
                    view.gotProperty && view.gotProperty( nodeID, propertyName, propertyValue );
                } );

            }

            this.logger.groupEnd(); this.logger.debug( "vwf.getProperty complete " + nodeID + " " + propertyName ); /* must log something for group level to reset in WebKit */

            return propertyValue;
        };

        this.getProperty.entrants = {}; // maps ( nodeID + '-' + propertyName ) => { index: i, value: v }

        // -- createMethod -------------------------------------------------------------------------

        this.createMethod = function ( nodeID, methodName ) {

            this.logger.group( "vwf.createMethod " + nodeID + " " + methodName );

            // Call creatingMethod() on each model. The method is considered created after each
            // model has run.

            vwf.models.forEach( function( model ) {
                model.creatingMethod && model.creatingMethod( nodeID, methodName );
            } );

            // Call createdMethod() on each view. The view is being notified that a method has been
            // created.

            vwf.views.forEach( function( view ) {
                view.createdMethod && view.createdMethod( nodeID, methodName );
            });

            this.logger.groupEnd(); this.logger.debug( "vwf.createMethod complete " + nodeID + " " + methodName ); /* must log something for group level to reset in WebKit */
        };

        // -- callMethod ---------------------------------------------------------------------------

        this.callMethod = function( nodeID, methodName /* [, parameter1, parameter2, ... ] */ ) { // TODO: parameters

            this.logger.group( "vwf.callMethod " + nodeID + " " + methodName ); // TODO: parameters

            var args = Array.prototype.slice.call( arguments );

            // Call callingMethod() on each model. The first model to return a non-undefined value
            // dictates the return value.

            var methodValue = undefined;

            vwf.models.forEach( function( model ) {
                var value = model.callingMethod && model.callingMethod.apply( model, args ); // TODO: parameters
                methodValue = value !== undefined ? value : methodValue;
            } );

            // Call calledMethod() on each view.

            vwf.views.forEach( function( view ) {
                view.calledMethod && view.calledMethod.apply( view, args ); // TODO: parameters
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.callMethod complete " + nodeID + " " + methodName ); /* must log something for group level to reset in WebKit */

            return methodValue;
        };

        // -- execute ------------------------------------------------------------------------------

        this.execute = function( nodeID, scriptText, scriptType ) {

            this.logger.group( "vwf.execute " + nodeID + " " + ( scriptText || "" ).replace( /\s+/g, " " ).substring( 0, 100 ) + " " + scriptType );

            // Assume javascript if the type is not specified.

            if ( ! scriptType && scriptText ) {
                scriptType = "application/javascript";
            }

            // Call executing() on each model. The script is considered executed after each model
            // has run.

            var scriptValue = undefined;

            vwf.models.some( function( model ) {
                scriptValue = model.executing && model.executing( nodeID, scriptText, scriptType );
                return scriptValue !== undefined;
            } );

            // Call executed() on each view. The view is being notified that a script has been
            // executed.

            vwf.views.forEach( function( view ) {
                view.executed && view.executed( nodeID, scriptText, scriptType );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.execute complete " + nodeID + " ... " + scriptType ); /* must log something for group level to reset in WebKit */

            return scriptValue;
        };

        // -- time ---------------------------------------------------------------------------------

        // Return the current simulation time;

        this.time = function() {

            // this.logger.debug( "vwf.time" );

            return this.now;
        };

        // -- logger_for ---------------------------------------------------------------------------

        // Create a logger for a module. Record the module name. Each logger method expects to
        // receive a function name as the first parameter. Prepend "<module_name>.<function_name>: "
        // to each output message.

        this.logger_for = function( module_name ) {

            return {

				enable: false,

                log: function( /* function_name, ... */ ) {
                    if ( this.enable ) {
						window.console && console.log && console.log.apply( console, prefixed_arguments.apply( this, arguments ) );
					}
                },

                debug: function( /* function_name, ... */ ) {
                    if ( this.enable ) {
						window.console && console.debug && console.debug.apply( console, prefixed_arguments.apply( this, arguments ) );
					}
                    // window.console && console.debug && console.debug.apply( console, prefixed_arguments.apply( this, arguments ) );
                },

                info: function( /* function_name, ... */ ) {
                    if ( this.enable ) {
						window.console && console.info && console.info.apply( console, prefixed_arguments.apply( this, arguments ) );
					}
                },

                warn: function( /* function_name, ... */ ) {
                    window.console && console.warn && console.warn.apply( console, prefixed_arguments.apply( this, arguments ) );
                },

                error: function( /* function_name, ... */ ) {
                    window.console && console.error && console.error.apply( console, prefixed_arguments.apply( this, arguments ) );
                },

                group: function( /* function_name, ... */ ) {
                    if ( this.enable ) {
						window.console && console.group && console.group.apply( console, prefixed_arguments.apply( this, arguments ) );
					}
                },

                groupCollapsed: function( /* function_name, ... */ ) {
                    if ( this.enable ) {
						window.console && console.groupCollapsed && console.groupCollapsed.apply( console, prefixed_arguments.apply( this, arguments ) );
					}
                },

                groupEnd: function( /* function_name, ... */ ) {
                    if ( this.enable ) {
						window.console && console.groupEnd && console.groupEnd.apply( console, prefixed_arguments.apply( this, arguments ) );
					}
                },

            };

            // Calculate an arguments array to pass to a logger function. Pass the arguments
            // following *function_name* through and prepend "<module_name>.<function_name>: ".

            function prefixed_arguments( /* function_name, ... */ ) {

                if ( arguments.length > 0 && ( typeof arguments[0] == "string" || arguments[0] instanceof String ) ) {
                    if ( arguments.length == 1 ) {
                        // just show the module and function name when there are no additional arguments
                        return [ module_name + "." + arguments[0] ];
                    } else if ( typeof arguments[1] == "string" || arguments[1] instanceof String ) {
                        // concatenate when the first field is a string so that it may remain a format string
                        return [ module_name + "." + arguments[0] + ": " + arguments[1] ].concat( Array.prototype.slice.call( arguments, 2 ) );
                    } else {
                        // otherwise insert a new first field
                        return [ module_name + "." + arguments[0] + ": " ].concat( Array.prototype.slice.call( arguments, 1 ) );
                    }
                } else {
                    return []; // no-op
                }

            }

        };

        // -- logger -------------------------------------------------------------------------------

        this.logger = {

			enable: false,
            log: function() { if ( this.enable ) { window.console && console.log && console.log.apply( console, arguments ) } },
            debug: function() { if ( this.enable ) { window.console && console.debug && console.debug.apply( console, arguments ) } },
            info: function() { if ( this.enable ) { window.console && console.info && console.info.apply( console, arguments ) } },
            warn: function() { window.console && console.warn && console.warn.apply( console, arguments ) },
            error: function() { window.console && console.error && console.error.apply( console, arguments ) },
            group: function() { if ( this.enable ) { window.console && console.group && console.group.apply( console, arguments ) } },
            groupCollapsed: function() { if ( this.enable ) { window.console && console.groupCollapsed && console.groupCollapsed.apply( console, arguments ) } },
            groupEnd: function() { if ( this.enable ) { window.console && console.groupEnd && console.groupEnd.apply( console, arguments ) } },

        };

        // == Private functions ====================================================================

        // -- construct ----------------------------------------------------------------------------

        // When we arrive here, we have a prototype node in hand (by way of its ID) and an object
        // containing a component specification. We now need to create and assemble the new node.
        // 
        // The VWF manager doesn't directly manipulate any node. The various models act in
        // federation to create the greater model. The manager simply routes messages within the
        // system to allow the models to maintain the necessary data. Additionally, the views
        // receive similar messages that allow them to keep their interfaces current.
        //
        // To create a node, we simply assign a new ID, then invoke a notification on each model and
        // a notification on each view.

        var construct = function( component, nodeID, prototypeID, callback /* ( nodeID, prototypeID ) */ ) {

            this.logger.group( "vwf.construct " + nodeID + " " + component.source + " " + component.type );

            async.series( [

                function( callback /* ( err, results ) */ ) {

                    // Call creatingNode() on each model. The node is considered to be constructed after
                    // each model has run.

                    async.forEachSeries( vwf.models, function( model, callback /* ( err ) */ ) {

                        var driver_ready = true;

                        model.creatingNode && model.creatingNode( nodeID, prototypeID, [], component.source, component.type, function( ready ) {
                            if ( Boolean( ready ) != Boolean( driver_ready ) ) {
                                vwf.logger.debug( "vwf.construct: creatingNode", ready ? "resuming" : "pausing", "at", nodeID, "for", component.source );
                                driver_ready = ready;
                                driver_ready && callback( undefined );
                            }
                        } );

                        driver_ready && callback( undefined );

                    }, function( err ) {
                        callback( err, undefined );
                    } );

                },

                function( callback /* ( err, results ) */ ) {

                    // Call createdNode() on each view. The view is being notified of a node that has
                    // been constructed.

                    async.forEach( vwf.views, function( view, callback /* ( err ) */ ) {

                        var driver_ready = true;

                        view.createdNode && view.createdNode( nodeID, prototypeID, [], component.source, component.type, function( ready ) {
                            if ( Boolean( ready ) != Boolean( driver_ready ) ) {
                                vwf.logger.debug( "vwf.construct: createdNode", ready ? "resuming" : "pausing", "at", nodeID, "for", component.source );
                                driver_ready = ready;
                                driver_ready && callback( undefined );
                            }
                        } );

                        driver_ready && callback( undefined );

                    }, function( err ) {
                        callback( err, undefined );
                    } );

                },

                function( callback /* ( err, results ) */ ) {

                    // Create the properties, methods, and events. For each item in each set, invoke
                    // createProperty(), createMethod(), or createEvent() to create the field. Each
                    // delegates to the models and views as above.

                    component.properties && jQuery.each( component.properties, function( propertyName, propertyValue ) {
                        if ( valueHasAccessors( propertyValue ) ) {
                            vwf.createProperty( nodeID, propertyName, propertyValue.value, propertyValue.get, propertyValue.set );
                        } else {
                            vwf.createProperty( nodeID, propertyName, propertyValue );
                        }
                    } );

                    component.methods && jQuery.each( component.methods, function( methodName ) {
                        vwf.createMethod( nodeID, methodName );
                    } );

                    component.events && jQuery.each( component.events, function( eventName ) {
                        vwf.createEvent( nodeID, eventName );
                    } );

                    callback( undefined, undefined );
                },

                function( callback /* ( err, results ) */ ) {

                    // Create and attach the children. For each child, call createNode() with the
                    // child's component specification, then once loaded, call addChild() to attach the
                    // new node as a child. addChild() delegates to the models and views as before.

                    async.forEach( Object.keys( component.children || {} ), function( childName, callback /* ( err ) */ ) {
                        vwf.createNode( component.children[childName], function( childID, childTypeID ) {
                            vwf.addChild( nodeID, childID, childName ); // TODO: add in original order from component.children
                            callback( undefined );
                        },
childName /* TODO: hack */ );
                    }, function( err ) {
                        callback( err, undefined );
                    } );

                },

                function( callback /* ( err, results ) */ ) {

                    // Attach the scripts. For each script, load the network resource if the script is
                    // specified as a URI, then once loaded, call execute() to direct any model that
                    // manages scripts of this script's type to evaluate the script where it will
                    // perform any immediate actions and retain any callbacks as appropriate for the
                    // script type.

                    component.scripts && component.scripts.forEach( function( script ) {
                        script.text && vwf.execute( nodeID, script.text, script.type ); // TODO: external scripts too // TODO: callback
                    } );

                    callback( undefined, undefined );
                },

                function( callback /* ( err, results ) */ ) {

// TODO: Adding the node to the tickable list here if it contains a tick() function in JavaScript at initialization time. Replace with better control of ticks on/off and the interval by the node.

if ( vwf.execute( nodeID, "Boolean( this.tick )" ) ) {
    vwf.tickable.nodeIDs.push( nodeID );
}

                    // Invoke an initialization method.

                    vwf.execute( nodeID, "this.initialize && this.initialize()",
                        "application/javascript" ); 

                    callback( undefined, undefined );
                },

            ], function( err, results ) {

                // The node is complete. Invoke the callback method and pass the new node ID and the
                // ID of its prototype. If this was the root node for the world, the world is now
                // fully initialized.

                callback && callback.call( vwf, nodeID, prototypeID );
            } );

            this.logger.groupEnd(); this.logger.debug( "vwf.construct complete " + nodeID + " " + component.source + " " + component.type ); /* must log something for group level to reset in WebKit */
        }

        // -- objectIsComponent --------------------------------------------------------------------

        // Determine if a JavaScript object is a component specification by searching for component
        // specification attributes in the candidate object.

        var objectIsComponent = function( candidate ) {

            var componentAttributes = [
                "extends",
                "implements",
                "source",
                "type",
                "properties",
                "methods",
                "events",
                "children",
                "scripts",
            ];

            var isComponent = false;

            if ( ( typeof candidate == "object" || candidate instanceof Object ) && candidate != null ) {

                componentAttributes.forEach( function( attributeName ) {
                    isComponent = isComponent || Boolean( candidate[attributeName] );
                } );

            }
            
            return isComponent; 
        };

        // -- valueHasAccessors --------------------------------------------------------------------

        // Determine if a property initializer is a detailed initializer containing explicit
        // accessor and value parameters (rather than being a simple value specification) by
        // searching for accessor attributes in the candidate object.

        var valueHasAccessors = function( candidate ) {

            var accessorAttributes = [
                "get",
                "set",
                "value",
            ];

            var hasAccessors = false;

            if ( ( typeof candidate == "object" || candidate instanceof Object ) && candidate != null ) {

                accessorAttributes.forEach( function( attributeName ) {
                    hasAccessors = hasAccessors || Boolean( candidate[attributeName] );
                } );

            }
            
            return hasAccessors; 
        };

        // -- normalizedComponent ------------------------------------------------------------------

        var normalizedComponent = function( /* component */ ) {

            var component = arguments[0]; // component is sometimes not writable when it is an argument?

            // Decode if JSON.

            if ( typeof component == "string" || component instanceof String ) {
                try { component = JSON.parse( component ) } catch( e ) { }
            }

            // Convert a component URI to an instance of that type. Convert an asset reference to
            // an untyped reference to that asset.

            if ( typeof component == "string" || component instanceof String ) { // TODO: validate URI
                component = component.match( /(^@)|(^http:\/\/vwf.example.com\/types\/)|(\.vwf$)/ ) ?
                    { "extends": component } : { source: component };  // TODO: detect component from mime-type instead of extension?  // TODO: this only detects .../types/camera (without .vwf extension) in the http://vwf.example.com/types/... domain.
            }

            // Fill in the mime type from the source specification if not provided.

            if ( component.source && ! component.type ) { // TODO: validate component

                var match = component.source.match( /\.([^.]*)$/ ); // TODO: get type from mime-type (from server if remote, from os if local, or (?) from this internal table otherwise)

                if ( match ) {

                    switch ( match[1] ) {
                        case "unity3d":
                            component.type = "application/vnd.unity";
                            break;
                        case "dae":
                            component.type = "model/vnd.collada+xml";
                            break;
                    }

                }

            }

            // Fill in the component type from the mime type if not provided.

            if ( component.type && ! component.extends ) { // TODO: load from a server configuration file

                switch ( component.type ) {
                    case "application/vnd.unity":
                        component.extends = "http://vwf.example.com/types/scene";
                        break;
                    case "model/vnd.collada+xml":
                        component.extends = "http://vwf.example.com/types/glge";
                        break;
                }

            }

            return component;
        };

        // -- loggableComponent --------------------------------------------------------------------

        // Return a copy of a component with the verbose bits truncated so that it may be written to
        // a log.

        var loggableComponent = function( component ) {

            var loggable = {};

            for ( var elementName in component ) {

                switch ( elementName ) {

                    case "properties":

                        loggable.properties = {};

                        for ( var propertyName in component.properties ) {

                            var componentPropertyValue = component.properties[propertyName];
                            var loggablePropertyValue = loggable.properties[propertyName] = {};

                            if ( valueHasAccessors( componentPropertyValue ) ) {
                                for ( var propertyElementName in componentPropertyValue ) {
                                    if ( propertyElementName == "set" || propertyElementName == "get" ) {
                                        loggablePropertyValue[propertyElementName] = "...";
                                    } else {
                                        loggablePropertyValue[propertyElementName] = componentPropertyValue[propertyElementName];
                                    }
                                }
                            } else {
                                loggable.properties[propertyName] = componentPropertyValue;
                            }

                        }

                        break;

                    case "children":

                        loggable.children = {};

                        for ( var childName in component.children ) {
                            loggable.children[childName] = {};
                        }

                        break;

                    case "scripts":

                        loggable.scripts = [];

                        component.scripts.forEach( function( script ) {

                            var loggableScript = {};

                            for ( var scriptElementName in script ) {
                                loggableScript[scriptElementName] = scriptElementName == "text" ? "..." : script[scriptElementName];
                            }

                            loggable.scripts.push( loggableScript );

                        } );

                        break;

                    default:

                        loggable[elementName] = component[elementName];

                        break;
                }

            }

            return loggable;
        };

        // -- remappedURI --------------------------------------------------------------------------

        // Remap a type identifier to its location in a local cache.

        // http://vwf.example.com/types/sometype => http://localhost:8001/types/sometype.vwf
        //                              ^------^                                ^------^

        var remappedURI = function( uri ) {

            var match = uri.match( RegExp( "http://vwf.example.com/types/(.*)" ) );

            if ( match ) {
                uri = window.location.protocol + "//" + window.location.host + "/types/" + match[1] + ".vwf";
            }

            return uri;

        };

        // -- getQueryString -----------------------------------------------------------------------

        // Retrieve parameters from the page's query string.

        // From http://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/2880929#2880929
        // and http://stackoverflow.com/questions/901115/get-querystring-values-with-jquery/3867610#3867610.

        var getQueryString = function( name ) {

            function parseParams() {
                var params = {},
                    e,
                    a = /\+/g, // regex for replacing addition symbol with a space
                    r = /([^&;=]+)=?([^&;]*)/g,
                    d = function( s ) { return decodeURIComponent( s.replace(a, " ") ); },
                    q = window.location.search.substring(1);

                while ( e = r.exec(q) )
                    params[ d(e[1]) ] = d(e[2]);

                return params;
            }

            if ( ! queryStringParams )
                queryStringParams = parseParams();

            return queryStringParams[name];
        };

    };

} ) ( window );
